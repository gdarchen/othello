\documentclass[11pt]{article}

%PRéAMBULE
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[table]{xcolor}
\usepackage[T1]{fontenc}
\usepackage[normalem]{ulem}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{fancybox}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{adjustbox}
\usepackage{amssymb,amsmath,latexsym}
\usepackage{mathrsfs}
\usepackage[a4paper]{geometry}
\usepackage{subfig}
\usepackage[bottom]{footmisc}
%%\usepackage{mathpazo}

\usepackage{algorithmeUTF8}



%TITRE
\geometry{hscale=0.8,vscale=0.8,centering}
\title{Projet Othello - \textsc{La conception détaillée}}
\author{Groupe 1.5}
\date{\today}

\begin{document}
\maketitle
\noindent\rule{\textwidth}{1.3pt}

\renewcommand{\tt}[1]{\og \texttt{#1} \fg}

\part{Conception détaillée des TAD}

\section{Conception détaillée des types}

\subsection{CD du type \tt{Couleur}}
\begin{itemize}
\type{Couleur}{\{blanc, noir\}}
\end{itemize}

\subsection{CD du type \tt{Pion}}
\begin{itemize}
\type{Pion}{Couleur}
\end{itemize}

\subsection{CD du type \tt{Position}}
\begin{itemize}
\item
\begin{algorithme}
\begin{enregistrement}{Position}
\champEnregistrement{ligne}{\naturel}
\champEnregistrement{colonne}{\naturel}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\subsection{CD du type \tt{Plateau}}
\begin{itemize}
\item
\begin{algorithme}
\begin{enregistrement}{Position}
\champEnregistrement{pions}{\tableauDeuxDimensions{1..8}{1..8}{de}{Pion}}
\champEnregistrement{presencePions}{\tableauDeuxDimensions{1..8}{1..8}{de}{\booleen}}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\subsection{CD du type \tt{Coup}}
\begin{itemize}\item
\begin{algorithme}
\begin{enregistrement}{Coup}
\champEnregistrement{position}{Position}
\champEnregistrement{pion}{Pion}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\subsection{CD du type \tt{Coups}}
\begin{itemize}
\type{Coups}{\tableauUneDimension{1..8}{de}{ Coup}}
\end{itemize}

\section{Conception détaillée des opérations des TAD}

\part{Conception détaillée des algorithmes compliqués de l'analyse \tt{faireUnePartie}}
\setcounter{section}{0}

\section{La procédure \tt{faireUnePartie}}
\begin{algorithme}
	\procedure{faireUnePartie}
	{\paramEntree{afficher : afficherPlateau, obtenirCoupJoueur1, obtenirCoupJoueur2 : getCoup}, \paramSortie{joueur : Couleur, estMatchNul : \booleen}}
	{plateau : Plateau \\
	aPuJouerJoueur1, aPuJouerJoueur2, estFinie : \booleen\\
	couleurJoueur1,couleurJoueur2 : Couleur \\
	nbPionsBlancs, nbPionsNoirs : \naturel}
	{
		\affecter{aPuJouerJoueur1}{VRAI}
		\affecter{aPuJouerJoueur2}{VRAI}
		\affecter{couleurJoueur1}{blanc()}
		\affecter{couleurJoueur2}{noir()}
		\affecter{estFinie}{FAUX}
		\affecter{nbPionsBlancs}{2}
		\affecter{nbPionsNoirs}{2}
		\affecter{plateau}{initialiserPlateau()}
		\instruction{afficher(plateau)}
		\tantque{non(estFinie)}{
			\instruction{jouer(plateau, couleurJoueur1, obtenirCoupJoueur1, aPuJouerJoueur1)}
			\instruction{afficher(plateau)}
			\instruction{jouer(plateau, couleurJoueur2, obtenirCoupJoueur1, aPuJouerJoueur2)}
			\instruction{afficher(plateau)}
			\instruction{finPartie(aPuJouerJoueur1, aPuJouerJoueur2, plateau, estFinie, nbPionsBlancs, nbPionsNoirs)}}%FinTantQue
		\sialorssinon{nbPionsBlancs $=$ nbPionsNoirs}
		{\affecter{joueur}{blanc()}
		\affecter{estMatchNul}{VRAI}}
		{\affecter{estMatchNul}{FAUX}
			\sialorssinon{nbPionsBlancs $ > $ nbPionsNoirs}
			{\affecter{joueur}{blanc()}}
			{\affecter{joueur}{noir()}}%FinSi
		}%FinSi
	}
\end{algorithme}


\section{La procédure \tt{jouer}}
\begin{algorithme}
	\procedure{jouer}
	{\paramEntreeSortie{plateau : Plateau, couleurJoueur : Couleur}, \paramEntree{obtenirCoupJoueur : getCoup}, \paramSortie{aPuJouer : \booleen}}
	{i : \naturel \\
	coups : Coups \\
	joueurCourant : Couleur \\
	coupJoueur : Coup \\
	res : \booleen}
	{\affecter{coupJoueur}{obtenirCoupJoueur(plateau,couleurJoueur)}
	\affecter{coups}{listeCoupsPossibles(plateau, couleurJoueur)}
	\pour{i}{1}{nbCoups(coups)}{}{
		\sialors{iemeCoup(coups,i) $=$ coup}
		{
			\instruction{jouerCoup(coupJoueur,plateau,res)}
		} %FinSi
	} %FinPour
	\affecter{aPuJouer}{res}

	}
\end{algorithme}

\section{La procédure \tt{jouerCoup}}
\begin{algorithme}
	\procedure{jouerCoup}
	{\paramEntree{coup : Coup}, \paramEntreeSortie{plateau : Plateau}, \paramSortie{plateauModifie : \booleen}}
	{i : \naturelNonNul \\
	aModifie,plateauDifferent : \booleen \\
	pas : \entier}
	{
		\instruction{poserPion(plateau, obtenirPositionCoup(coup), obtenirPionCoup(coup))}
		\affecter{plateauDifferent}{FAUX}
		\pour{i}{1}{3}{2}{
			\affecter{pas}{i $-$ 2}
			\instruction{inverserLigne(pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau, aModifie)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
			\instruction{inverserColonne(pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau, aModifie)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
			\instruction{inverserDiag(pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau, aModifie)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
		}%FinPour
	}
\end{algorithme}

\section{La procédure \tt{inverserLigne}}
\begin{algorithme}
	\procedure{inverserLigne}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}, \paramSortie{aModifie : \booleen}}
	{i,j,k,l : \naturel \\
	test : \booleen}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\affecter{k}{j $+$ pas}
		\affecter{test}{FAUX}
		\tantque{((k $>$ 0) et (k $\leqslant$ 8) et (test $=$ FAUX) et non(estCaseVide(plateau, fixerPosition(i,k))))}{
		\sialorssinon{obtenirPion(plateau, fixerPosition(i, k)) = pionJoueur}
		{\affecter{test}{VRAI}
		\sialors{(k$>$j$+$1) ou (k$<$j$-$1)}{
			      \affecter{aModifie}{VRAI}
			}}
		{\affecter{k}{k $+$ pas}}%FinSi
		}%FinTantQue
		\sialors{test}
		{\pour{l}{k $-$ pas}{j $+$ pas}{}
		{\instruction{inverserPion(plateau, fixerPosition(i, l))}}%FinPour
		}%FinSi
	}
\end{algorithme}

\section{La procédure \tt{inverserColonne}}
\begin{algorithme}
	\procedure{inverserColonne}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}, \paramSortie{aModifie : \booleen}}
	{i, j, k, l : \naturel \\
	test, aModifie : \booleen}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\affecter{k}{j $+$ pas}
		\affecter{test}{FAUX}
		\tantque{((k $ > $ 0) et (k $\leqslant $ 8) et (test $ = $ FAUX) et non(estCaseVide(plateau, fixerPosition(k,j))))}{
			\sialorssinon{obtenirPion(plateau, fixerPosition(k,j)) = pionJoueur}
			{\affecter{test}{VRAI}
			\sialors{(k $>$ j$+$1) ou (k$<$ j$-$1)}{
			      \affecter{aModifie}{VRAI}
			}}
			{\affecter{k}{k $+$ pas}}%FinSi
		} %FinTantQue
		\sialors{test}{
			\pour{l}{k $-$ pas}{i $+$ pas}{}{
			\instruction{inverserPion(plateau, fixerPosition(l, j))}
			}%FinPour
		}%FinSi
	}
\end{algorithme}

\section{La procédure \tt{inverserDiag}}
\begin{algorithme}
	\procedure{inverserDiag}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}, \paramSortie{aModifie : \booleen}}
	{i, j, k, l, m, n, o : \naturel \\
	pasDiag : \entier}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\affecter{k}{j $+$ pas}

		\affecter{test}{FAUX}

		\pour{o}{1}{3}{2}{
		  \affecter{pasDiag}{o $-$ 2}
		  \affecter{m}{i $+$ pasDiag}
		  \tantque{((k $>$ 0) et (k $\leqslant$ 8) et (m $>$ 0) et (test $=$ FAUX) et non(estCaseVide(plateau, fixerPosition(m, k))))}{
			  \sialorssinon{obtenirPion(plateau, fixerPosition(m, k)) $=$ pionJoueur}
			  {\affecter{test}{VRAI}
			  \sialors{(k>j+1) ou (k<j-1)}{
				\affecter{aModifie}{VRAI}
			  }}
			  {\affecter{k}{j $+$ pas}
			  \affecter{m}{m $-$ 1}}%FinSi
		  }%FinTantQue
		  \sialors{test}
		  {
			  \affecter{l}{m $+$ 1}
			  \affecter{n}{k $-$ pas}
			  \repeter{
				  \instruction{inverserPion(plateau, fixerPosition(l, n))}
				  \affecter{l}{l $+$ 1}
				   \affecter{n}{n $-$ pas}
			  }{l $=$ i}%FinRepeter
		  } %FinSI
		}
	}
\end{algorithme}


\part{Conception détaillée des algorithmes compliqués de l'analyse \tt{obtenirCoupIA}}
\setcounter{section}{0}
\section{La fonction \tt{obtenirCoupIA}}
\begin{algorithme}
	\fonction
	{obtenirCoupIA}
	{plateau : Plateau, couleur : Couleur}
	{Coup}{i, pronfondeurMinMax : \naturel \\
	coupsPossibles : Coups \\
	plateauTest : Plateau \\
	scoreCourant, meilleurScore : \entier\\
	coupCourant, meilleurCoup : Coup}
	{
	\affecter{profondeurMinMax}{profondeur()}
	\affecter{coupsPossibles}{listeCoupsPossibles(plateau, couleur)}
	\sialors{nbCoups(coupsPossibles) $>$ 0}
		{
			\affecter{meilleurCoup}{iemeCoup(coupsPossibles, 1)}
			\affecter{plateauTest}{copierPlateau(plateau)}
			\affecter{meilleurScore}{scoreDUnCoup(plateauTest, meilleurCoup, couleur)}
			\pour{i}{2}{nbCoups(coupsPossibles)}{}{
				\affecter{coupCourant}{iemeCoup(coupsPossibles, i)}
				\affecter{plateauTest}{copierPlateau(plateau)}
				\affecter{scoreCourant}{scoreDUnCoup(plateauTest, coupCourant, couleur)}
				\sialors{scoreCourant $>$ meilleurScore}{
					\affecter{meilleurCoup}{coupCourant}
					\affecter{meilleurScore}{scoreCourant}
				} %FinSi
			} %FinPour
		} %FinSi
		\retourner{meilleurCoup}

	}
\end{algorithme}



\section{La fonction \tt{scoreDUnCoup}}
\begin{algorithme}
	\fonction
	{scoreDUnCoup}
	{plateau : Plateau, coup : Coup, couleurRef, couleurCourante : Couleur, profondeurCourante : \naturel}
	{\entier}
	{}
	{
	\instruction{jouerCoup(coup, plateau)}
	\sialorssinon{plateauRempli(plateau) ou profondeurCourante $=$ 0}
		{
			\retourner{score(plateau, couleurRef)}
		} % Sinon
		{
			\retourner{minMax(plateau, couleurRef, changerCouleur(CouleurCourante), profondeurCourante $-$ 1)}
		} % FinSi
	} % Fin
\end{algorithme}


\section{La fonction \tt{coupValide}}

\begin{algorithme}

	\fonction{coupValide}
	{plateau : Plateau, coup : Coup}
	{\booleen}
	{estValide, aVoisinAutreCouleur : \booleen \\
	pos : Position \\
	plateauTmp : Plateau \\
	i,j : \naturel \\
	couleurJoueur, autreCouleur : Couleur}
	{
	\affecter{couleurJoueur}{obtenirCouleurPion(obtenirPionCoup(coup))}
	\affecter{autreCouleur}{changerCouleur(couleurJoueur)}
	\affecter{pos}{obtenirPositionCoup(coup)}
	\affecter{i}{obtenirLigne(pos)}
	\affecter{j}{obtenirColonne(pos)}
	\affecter{aVoisinAutreCouleur}{\\\Big[\big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i$-$1, j$-$1))) $=$ autreCouleur\big) ou \\
	    \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i$-$1, j))) $=$ autreCouleur\big) ou \\
		 \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i$-$1, j$+$1))) $=$ autreCouleur\big) ou \\
		 \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i, j$-$1))) $=$ autreCouleur\big) ou \\
		 \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i, j$+$1))) $=$ autreCouleur\big) ou \\
		 \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i$+$1, j$-$1))) $=$ autreCouleur\big) ou \\
		 \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i$+$1, j))) $=$ autreCouleur\big) ou \\
		 \big(obtenirCouleurPion(obtenirPion(plateau, fixerPosition(i$+$1, j$+$1))) $=$ autreCouleur\big)\Big]}
	\sialors{aVoisinAutreCouleur}{
		\affecter{plateauTmp}{copierPlateau(plateau, plateauTmp)}
		\instruction{jouerCoup(coup, plateauTmp, estValide)}
	}
	\retourner{estValide}
	}
\end{algorithme}


\section{La fonction \tt{minMax}}
\begin{algorithme}
	\fonction{minMax}
	{plateau : Plateau, couleurRef, couleurCourante : Couleur, profondeurCourante : \naturel}
	{\entier}
	{coupsPossibles : Coups \\
	resultat, score : \entier \\
	i : \naturel}
	{
	\affecter{coupsPossibles}{listeCoupsPossibles(plateau, couleurCourante)}
	\sialorssinon{nbCoups(coupsPossibles) $>$ 0}
		{
		\affecter{resultat}{scoreDUnCoup(plateau, iemeCoup(coupsPossibles, 1), couleurRef, couleurCourante, profondeurCourante)}
		\pour{i}{2}{nbCoups(coupsPossibles)}{}
			{
			\affecter{score}{scoreDUnCoup(plateau,iemeCoup(coupsPossibles, i), couleurRef, couleurCourante, profondeurCourante)}
			\sialorssinon{couleurCourante $=$ couleurRef}
				{\affecter{resultat}{max(resultat, score)}}
				{\affecter{resultat}{min(resultat, score)}}
			}
		}
		{
		\sialorssinon{couleurCourante $=$ couleurRef}
			{\affecter{resultat}{INFINI}}
			{\affecter{resultat}{$-$ INFINI}}
		}
	\retourner{resultat}
	}
	
	\remarque{On utilise ici une constante \tt{INFINI}, qui représentera un score supérieur à tout autre score, c'est-à-dire un coup gagnant.}
\end{algorithme}

\end{document}