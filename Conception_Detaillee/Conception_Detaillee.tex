\documentclass[11pt]{article}

%PRéAMBULE
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[table]{xcolor}
\usepackage[T1]{fontenc}
\usepackage[normalem]{ulem}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{fancybox}
\usepackage{amsfonts}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{adjustbox}
\usepackage{amssymb,amsmath,latexsym}
\usepackage{mathrsfs}
\usepackage[a4paper]{geometry}
\usepackage{subfig}
\usepackage[bottom]{footmisc}
%%\usepackage{mathpazo}

\usepackage{algorithmeUTF8}



%TITRE
\geometry{hscale=0.8,vscale=0.8,centering}
\title{Projet Othello - \textsc{La conception détaillée}}
\author{Groupe 1.5}
\date{\today}

\begin{document}
\maketitle
\noindent\rule{\textwidth}{1.3pt}

\renewcommand{\tt}[1]{\og \texttt{#1} \fg}

\part{Conception détaillée des TAD}

\section{Conception détaillée des types}

\subsection{CD du type \tt{Couleur}}
\begin{itemize}
\type{Couleur}{\{blanc, noir\}}
\end{itemize}

\subsection{CD du type \tt{Pion}}
\begin{itemize}
\type{Pion}{Couleur}
\end{itemize}

\subsection{CD du type \tt{Position}}
\begin{itemize}
\item
\begin{algorithme}
\begin{enregistrement}{Position}
\champEnregistrement{ligne}{\naturel}
\champEnregistrement{colonne}{\naturel}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\subsection{CD du type \tt{Plateau}}
\begin{itemize}
\item
\begin{algorithme}
\begin{enregistrement}{Position}
\champEnregistrement{pions}{\tableauDeuxDimensions{1..8}{1..8}{de}{Pion}}
\champEnregistrement{presencePions}{\tableauDeuxDimensions{1..8}{1..8}{de}{\booleen}}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\subsection{CD du type \tt{Coup}}
\begin{itemize}\item
\begin{algorithme}
\begin{enregistrement}{Coup}
\champEnregistrement{position}{Position}
\champEnregistrement{pion}{Pion}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\subsection{CD du type \tt{Coups}}
\begin{itemize}
\type{Coups}{\tableauUneDimension{1..8}{de}{ Coup}}
\end{itemize}

\section{Conception détaillée des opérations des TAD}

\part{Conception détaillée des algorithmes compliqués de l'analyse \tt{faireUnePartie}}
\setcounter{section}{0}

\section{La procédure \tt{faireUnePartie}}
\begin{algorithme}
	\procedure{faireUnePartie}
	{\paramEntree{afficher : afficherPlateau, obtenirCoupJoueur1, obtenirCoupJoueur2 : getCoup}, \paramSortie{joueur : Couleur, estMatchNul : \booleen}}
	{plateau : Plateau \\
	aPuJouerJoueur1, aPuJouerJoueur2, estFinie, plateauModifie : \booleen\\
	couleurJoueur1,couleurJoueur2 : Couleur \\
	nbPionsBlancs, nbPionsNoirs : \naturel}
	{
		\affecter{aPuJouerJoueur1}{VRAI}
		\affecter{aPuJouerJoueur2}{VRAI}
		\affecter{couleurJoueur1}{blanc()}
		\affecter{couleurJoueur2}{noir()}
		\affecter{estFinie}{FAUX}
		\affecter{nbPionsBlancs}{2}
		\affecter{nbPionsNoirs}{2}
		\affecter{plateau}{initialiserPlateau()}
		\instruction{afficher(plateau)}
		\tantque{non(estFinie)}{
			\instruction{jouer(plateau, couleurJoueur1, obtenirCoupJoueur1, aPuJouerJoueur1, plateauModifie)}
			\instruction{afficher(plateau)}
			\instruction{jouer(plateau, couleurJoueur2, obtenirCoupJoueur1, aPuJouerJoueur2, plateauModifie)}
			\instruction{afficher(plateau)}
			\instruction{finPartie(aPuJouerJoueur1, aPuJouerJoueur2, plateau, estFinie, nbPionsBlancs, nbPionsNoirs)}}%FinTantQue
		\sialorssinon{nbPionsBlancs $=$ nbPionsNoirs}
		{\affecter{joueur}{blanc()}
		\affecter{estMatchNul}{VRAI}}
		{\affecter{estMatchNul}{FAUX}
			\sialorssinon{nbPionsBlancs $ > $ nbPionsNoirs}
			{\affecter{joueur}{blanc()}}
			{\affecter{joueur}{noir()}}%FinSi
		}%FinSi
	}
\end{algorithme}


\section{La procédure \tt{jouer}}
\begin{algorithme}
	\procedure{jouer}
	{\paramEntreeSortie{plateau : Plateau, couleurJoueur : Couleur}, \paramEntree{obtenirCoupJoueur : getCoup}, \paramSortie{aPuJouer : \booleen}}
	{i : \naturel \\
	coups : Coups \\
	joueurCourant : Couleur \\
	coupJoueur : Coup \\
	res : \booleen}
	{\affecter{coupJoueur}{obtenirCoupJoueur(plateau,couleurJoueur)}
	\affecter{coups}{listeCoupsPossibles(plateau, couleurJoueur)}
	\pour{i}{1}{nbCoups(coups)}{}{
		\sialorssinon{iemeCoup(coups,i) $=$ coup}
		{	\affecter{res}{VRAI}
			\instruction{jouerCoup(coupJoueur,plateau)}
		}
		{\affecter{res}{FAUX}
		} %FinSi
	} %FinPour
	\affecter{aPuJouer}{res}

	}
\end{algorithme}

\section{La procédure \tt{jouerCoup}}
\begin{algorithme}
	\procedure{jouerCoup}
	{\paramEntree{coup : Coup}, \paramEntreeSortie{plateau : Plateau}, \paramSortie{plateauModifie : \booleen}}
	{i : \naturelNonNul \\
	aModifie,plateauDifferent : \booleen \\
	pas : \entier}
	{
		\instruction{poserPion(plateau, obtenirPositionCoup(coup), obtenirPionCoup(coup))}
		\affecter{plateauDifferent}{FAUX}
		\pour{i}{1}{3}{2}{
			\affecter{pas}{i $-$ 2}
			\instruction{inverserLigne(aModifie, pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
			\instruction{inverserColonne(aModifie, pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
			\instruction{inverserDiagMontante(aModifie, pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
			\instruction{inverserDiagDescendante(aModifie, pas, obtenirPositionCoup(coup), obtenirPionCoup(coup), plateau)}
			\sialors{aModifie}
			{
			      \affecter{plateauDifferent}{VRAI}
			}%FinSi
		}%FinPour
	}
\end{algorithme}

\section{La procédure \tt{inverserLigne}}
\begin{algorithme}
	\procedure{inverserLigne}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}}
	{i,j,k,l : \naturel \\
	test : \booleen}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\affecter{k}{j $+$ pas}
		\affecter{test}{FAUX}
		\tantque{((k $>$ 0) et (k $\leqslant$ 8) et (test $=$ FAUX) et non(estCaseVide(plateau, fixerPosition(i,k))))}{
		\sialorssinon{obtenirPion(plateau, fixerPosition(i, k)) = pionJoueur}
		{\affecter{test}{VRAI}}
		{\affecter{k}{k $+$ pas}}%FinSi
		}%FinTantQue
		\sialors{test}
		{\pour{l}{k $-$ pas}{j $+$ pas}{}
		{\instruction{inverserPion(plateau, fixerPosition(i, l))}}%FinPour
		}%FinSi
	}
\end{algorithme}

\section{La procédure \tt{inverserColonne}}
\begin{algorithme}
	\procedure{inverserColonne}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}, \paramSortie{test : \booleen}}
	{i, j, k, l : \naturel \\
	test : \booleen}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\affecter{k}{j $+$ pas}
		\affecter{test}{FAUX}
		\tantque{((k $ > $ 0) et (k $\leqslant $ 8) et (test $ = $ FAUX) et non(estCaseVide(plateau, fixerPosition(k,j))))}{
			\sialorssinon{obtenirPion(plateau, fixerPosition(k,j)) = pionJoueur}
			{\affecter{test}{VRAI}}
			{\affecter{k}{k $+$ pas}}%FinSi
		} %FinTantQue
		\sialors{test}{
			\pour{l}{k $-$ pas}{i $+$ pas}{}{
			\instruction{inverserPion(plateau, fixerPosition(l,j))}
			}%FinPour
		}%FinSi
	}
\end{algorithme}

\section{La procédure \tt{inverserDiagMontante}}
\begin{algorithme}
	\procedure{inverserDiagMontante}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}}
	{i, j, k, l, m, n : \naturel}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColone(pos)}
		\affecter{k}{j $+$ pas}
		\affecter{m}{i $-$ 1}
		\affecter{test}{FAUX}
		\tantque{((k $>$ 0) et (k $\leqslant$ 8) et (m $>$ 0) et (test $=$ FAUX) et non(estCaseVide(plateau, fixerPosition(m, k))))}{
			\sialorssinon{obtenirPion(plateau, fixerPosition(m, k)) $=$ pionJoueur}
			{\affecter{test}{VRAI}}
			{\affecter{k}{j $+$ pas}
			\affecter{m}{m $-$ 1}}%FinSi
		}%FinTantQue
		\sialors{test}
		{
			\affecter{l}{m $+$ 1}
			\affecter{n}{k $-$ pas}
			\repeter{
				\instruction{inverserPion(plateau, fixerPosition(l, n))}
				\affecter{l}{l $+$ 1}
				\affecter{n}{n $-$ pas}
			}{l $=$ i}%FinRepeter
		} %FinSI
	}
\end{algorithme}


\section{La procédure \tt{inverserDiagDescendante}}
\begin{algorithme}
	\procedure{inverserDiagDescendante}
	{\paramEntree{pas : \entier, pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}}
	{i, j, k, l, m, n : \naturel}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColone(pos)}
		\affecter{k}{j $+$ pas}
		\affecter{m}{i $+$ 1}
		\affecter{test}{FAUX}
		\tantque{((k $>$ 0) et (k $\leqslant$ 8) et (m $\leqslant$ 8) et (test $=$ FAUX) et non(estCaseVide(plateau, fixerPosition(m, k))))}{
			\sialorssinon{obtenirPion(plateau, fixerPosition(m, k)) $=$ pionJoueur}
			{\affecter{test}{VRAI}}
			{\affecter{k}{j $+$ pas}
			\affecter{m}{m $+$ 1}}%FinSi
		}%FinTantQue
		\sialors{test}
		{
			\affecter{l}{m $-$ 1}
			\affecter{n}{k $-$ pas}
			\repeter{
				\instruction{inverserPion(plateau, fixerPosition(l, n))}
				\affecter{l}{l $-$ 1}
				\affecter{n}{n $-$ pas}
			}{l $=$ i}%FinRepeter
		} %FinSI
	}
\end{algorithme}


\part{Conception détaillée des algorithmes compliqués de l'analyse \tt{obtenirCoupIA}}
\setcounter{section}{0}
\section{La fonction \tt{obtenirCoupIA}}
\begin{algorithme}
	\fonction
	{obtenirCoupIA}
	{plateau : Plateau, couleur : Couleur}
	{Coup}{i, pronfondeurMinMax : \naturel \\
	coupsPossibles : Coups \\
	plateauTest : Plateau \\
	scoreCourant, meilleurScore : \entier\\
	coupCourant, meilleurCoup : Coup}
	{
	\affecter{profondeurMinMax}{profondeur()}
	\affecter{coupsPossibles}{listeCoupsPossibles(plateau,couleur)}
	\sialors{nbCoups(coupsPossibles) $>$ 0}
		{
			\affecter{meilleurCoup}{iemeCoup(coupsPossibles,1)}
			\affecter{plateauTest}{copierPlateau(plateau)}
			\affecter{meilleurScore}{scoreDUnCoup(plateauTest,meilleurCoup,couleur)}
			\pour{i}{2}{nbCoups(coupsPossibles)}{}{
				\affecter{coupCourant}{iemeCoup(coupsPossibles,i)}
				\affecter{plateauTest}{copierPlateau(plateau)}
				\affecter{scoreCourant}{scoreDUnCoup(plateauTest,coupCourant,couleur)}
				\sialors{scoreCourant $>$ meilleurScore}{
					\affecter{meilleurCoup}{coupCourant}
					\affecter{meilleurScore}{scoreCourant}
				} %FinSi
			} %FinPour
		} %FinSi
		\retourner{meilleurCoup}

	}
\end{algorithme}

\section{La fonction \tt{coupValide}}
\begin{algorithme}

	\fonction{coupValide}
	{plateau : Plateau, coup : Coup}
	{\booleen}
	{estValide, aVoisinAutreCouleur : \booleen \\
	pos : Position \\
	plateauTmp : Plateau \\
	i,j : \naturel \\
	couleurJoueur, autreCouleur : Couleur}
	{
	\affecter{couleurJoueur}{obtenirCouleurPion(obtenirPionCoup(coup))}	
	\affecter{autreCouleur}{changerCouleur(couleurJoueur)}
	\affecter{pos}{obtenirPositionCoup(coup)}
	\affecter{i}{obtenirLigne(pos)}
	\affecter{j}{obtenirColonne(pos)}
	\affecter{aVoisinAutreCouleur}{obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i-1,j-1)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i-1,j)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i-1,j+1)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i,j-1)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i,j+1)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i+1,j-1)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i+1,j)))=autreCouleur ou \\
				      obtenirCouleurPion(obtenirPion(plateau,fixerPosition(i+1,j+1)))=autreCouleur}
	\sialors{aVoisinAutreCouleur}{
		\affecter{plateauTmp}{copierPlateau(plateau, plateauTmp}
		\instruction{jouerCoup(coup, plateauTmp, estValide}
	}
	\retourner{estValide}	
		
	}

\end{algorithme}

\end{document}
