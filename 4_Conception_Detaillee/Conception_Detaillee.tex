%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fichier de la Conception Détaillée %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conception détaillée des TAD}

\section{CD du type \tt{Couleur}}
\begin{itemize}
\type{Couleur}{\{blanc, noir\}}
\end{itemize}

\section{CD du type \tt{Pion}}
\begin{itemize}
\type{Pion}{Couleur}
\end{itemize}

\section{CD du type \tt{Position}}
\begin{itemize}
\item
\begin{algorithme}
\begin{enregistrement}{Position}
\champEnregistrement{ligne}{\naturel}
\champEnregistrement{colonne}{\naturel}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\section{CD du type \tt{Plateau}}
\begin{itemize}
\item
\begin{algorithme}
\begin{enregistrement}{Position}
\champEnregistrement{pions}{\tableauDeuxDimensions{1..8}{1..8}{de}{Pion}}
\champEnregistrement{presencePions}{\tableauDeuxDimensions{1..8}{1..8}{de}{\booleen}}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\section{CD du type \tt{Coup}}
\begin{itemize}\item
\begin{algorithme}
\begin{enregistrement}{Coup}
\champEnregistrement{position}{Position}
\champEnregistrement{pion}{Pion}
\end{enregistrement}
\end{algorithme}
\end{itemize}

\section{CD du type \tt{Coups}}
\begin{itemize} \item
\begin{algorithme}
\begin{enregistrement}{Coups}
\champEnregistrement{tabCoups}{\tableauUneDimension{1..60}{de}{Coup}}
\champEnregistrement{nbCps}{\naturel}
\end{enregistrement}
\end{algorithme}
\end{itemize}


\chapter{Conception détaillée des algorithmes compliqués de l'analyse \tt{faireUnePartie}}
\setcounter{section}{0}

\section{La procédure \tt{faireUnePartie}}
\begin{algorithme}
	\procedure{faireUnePartie}
	{\paramEntree{afficher : afficherPlateau, obtenirCoupJoueur1, obtenirCoupJoueur2 : getCoup}, \paramSortie{joueur : Couleur, estMatchNul : \booleen}}
	{plateau : Plateau \\
	aPuJouerJoueur1, aPuJouerJoueur2, estFinie : \booleen\\
	couleurJoueur1,couleurJoueur2 : Couleur \\
	nbPionsBlancs, nbPionsNoirs : \naturel}
	{
		\affecter{aPuJouerJoueur1}{VRAI}
		\affecter{aPuJouerJoueur2}{VRAI}
		\affecter{couleurJoueur1}{blanc()}
		\affecter{couleurJoueur2}{noir()}
		\affecter{estFinie}{FAUX}
		\affecter{nbPionsBlancs}{2}
		\affecter{nbPionsNoirs}{2}
		\affecter{plateau}{initialiserPlateau()}
		\instruction{afficher(plateau)}
		\tantque{non(estFinie)}{
			\instruction{jouer(plateau, couleurJoueur1, obtenirCoupJoueur1, aPuJouerJoueur1)}
			\instruction{afficher(plateau)}
			\instruction{finPartie(aPuJouerJoueur1, aPuJouerJoueur2, plateau, estFinie, nbPionsBlancs, nbPionsNoirs)}
			\instruction{jouer(plateau, couleurJoueur2, obtenirCoupJoueur1, aPuJouerJoueur2)}
			\instruction{afficher(plateau)}
			\instruction{finPartie(aPuJouerJoueur1, aPuJouerJoueur2, plateau, estFinie, nbPionsBlancs, nbPionsNoirs)}}%FinTantQue
		\sialorssinon{nbPionsBlancs $=$ nbPionsNoirs}
		{\affecter{joueur}{blanc()}
		\affecter{estMatchNul}{VRAI}}
		{\affecter{estMatchNul}{FAUX}
			\sialorssinon{nbPionsBlancs $ > $ nbPionsNoirs}
			{\affecter{joueur}{blanc()}}
			{\affecter{joueur}{noir()}}%FinSi
		}%FinSi
	}
\end{algorithme}


\section{La procédure \tt{jouer}}
\begin{algorithme}
	\procedure{jouer}
	{\paramEntreeSortie{plateau : Plateau, couleurJoueur : Couleur}, \paramEntree{obtenirCoupJoueur : getCoup}, \paramSortie{aPuJouer : \booleen}}
	{i : \naturel \\
	coups : Coups \\
	joueurCourant : Couleur \\
	coupJoueur : Coup}
	{\affecter{coupJoueur}{obtenirCoupJoueur(plateau,couleurJoueur)}
	\affecter{coups}{listeCoupsPossibles(plateau, couleurJoueur)}
	\pour{i}{1}{nbCoups(coups)}{}{
		\sialors{iemeCoup(coups,i) $=$ coup}
		{
			\instruction{jouerCoup(coupJoueur,plateau)}
		} %FinSi
	} %FinPour
	\affecter{aPuJouer}{res}

	}
\end{algorithme}

\section{La procédure \tt{jouerCoup}}
\begin{algorithme}
	\procedure{jouerCoup}
	{\paramEntree{coup : Coup}, \paramEntreeSortie{plateau : Plateau}}
	{i : \naturelNonNul}
	{
		\instruction{poserPion(plateau, obtenirPositionCoup(coup), obtenirPionCoup(coup))}
		\affecter{pos}{obtenirPositionCoup(coup)}
		\affecter{pionJoueur}{obtenirPionCoup(coup)}
		\instruction{inverserPions(pos, pionJoueur, plateau : Plateau)}
	}
\end{algorithme}


\section{La procédure \tt{inverserPions}}

\begin{algorithme}
	\procedure{inverserPions}
	{\paramEntree{pos : Position, pionJoueur : Pion}, \paramEntreeSortie{plateau : Plateau}}
	{posTmp : Position \\
	x,y : \entier \\
	i,j : \naturelNonNul \\
	pionPresent : \booleen}
	{
	      \pour{i}{1}{3}{}{	
		    \affecter{x}{i $-$ 2}
		    \pour{j}{1}{3}{}{	
			  \affecter{y}{i $-$ 2}
			  \sialors{non (x $=$ 0) et (y $=$ 0)}{
				\affecter{posTmp}{pos}
				\instruction{pionEstPresent(pionJoueur, x, y, posTmp, plateau, pionPresent)}
				\sialors{pionPresent}{
				      \instruction{inverserPionsDir(plateau, pos, posTmp, -x, -y)}
				}%FinSi
			  }%FinSi
		    }%FinPour
	      }%FinPour
	}
\end{algorithme}


\section{La procédure \tt{inverserPionsDir}}

\begin{algorithme}
	\procedure{inverserPionsDir}
	{\paramEntreeSortie{plateau : Plateau}, \paramEntree{posInitiale, posCourante : Position, x, y : \entier}}
	{i,j : \naturelNonNul}
	{	
		\affecter{i}{obtenirLigne(posCourante)}
		\affecter{j}{obtenirColonne(posCourante)}
		\sialors{non (posInitiale $=$ posCourante)}{
			\instruction{inverserPion(plateau,posCourante)}
      			\affecter{posCourante}{fixerPosition(x+i, y+j)}
      			\instruction{inverserPionsDir(plateau, posInitiale, posCourante, x, y)}
		}%FinSi
	}
\end{algorithme}

\section{La procédure \tt{pionEstPresent}}

\begin{algorithme}
	\procedure{pionEstPresent}
	{\paramEntree{pionJoueur : Pion, x, y : \entier}, \paramEntreeSortie{pos : Position, plateau : Plateau}, \paramSortie{pionPresent : \booleen}}
	{i,j : \naturelNonNul}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\sialorssinon{((x+i)<1) ou ((x+i)>8) ou ((y+j)<1) ou ((y+j)>8)}{
		      \affecter{pionPresent}{FAUX}
		}
		{
		      \affecter{pos}{fixerPosition(x+i, y+j)}
		      \instruction{pionEstPresentRecursif(pionJoueur, x, y, pos, plateau, pionPresent)}
		}%FinSi
	}
\end{algorithme}

\section{La procédure \tt{pionEstPresentRecursif}}
\begin{algorithme}
	\procedure{pionEstPresentRecursif}
	{\paramEntree{pionJoueur : Pion, x, y : \entier}, \paramEntreeSortie{pos : Position, plateau : Plateau}, \paramSortie{pionPresent : \booleen}}
	{i,j : \naturelNonNul \\
	couleurJoueur : Couleur}
	{
		\affecter{i}{obtenirLigne(pos)}
		\affecter{j}{obtenirColonne(pos)}
		\affecter{couleurJoueur}{obtenirCouleurPion(pionJoueur)}
		\sialorssinon{estCaseVide(plateau, pos)}{
		      \affecter{pionPresent}{FAUX}
		}
		{
		      \sialorssinon{obtenirCouleurPion(obtenirPion(plateau, pos)) $=$ couleurJoueur}{
			    \affecter{pionPresent}{VRAI}
		      }
		      {
			    \sialorssinon{((x+i)<1) ou ((x+i)>8) ou ((y+j)<1) ou ((y+j)>8)}{
				  \affecter{pionPresent}{FAUX}
			    }
			    {
				  \affecter{pos}{fixerPosition(x+i, y+j)}
				  \instruction{pionEstPresentRecursif(pionJoueur, x, y, pos, plateau, pionPresent)}
			    }%FinSi
		      }%FinSi
		}%FinSi
	}
\end{algorithme}


\chapter{Conception détaillée des algorithmes compliqués de l'analyse \tt{obtenirCoupIA}}
\setcounter{section}{0}
\section{La fonction \tt{obtenirCoupIA}}
\begin{algorithme}
	\fonction
	{obtenirCoupIA}
	{plateau : Plateau, couleur : Couleur}
	{Coup}
	{i, pronfondeurMinMax : \naturel \\
	coupsPossibles : Coups \\
	scoreCourant, meilleurScore : \entier\\
	coupCourant, meilleurCoup : Coup}
	{
	\affecter{profondeurMinMax}{profondeur()}
	\affecter{coupsPossibles}{listeCoupsPossibles(plateau, couleur)}
	\sialors{nbCoups(coupsPossibles) $>$ 0}
		{
			\affecter{meilleurCoup}{iemeCoup(coupsPossibles, 1)}
			\affecter{meilleurScore}{scoreDUnCoup(plateau, meilleurCoup, couleur, couleur, profondeurMinMax)}
			\pour{i}{2}{nbCoups(coupsPossibles)}{}{
				\affecter{coupCourant}{iemeCoup(coupsPossibles, i)}
				\affecter{scoreCourant}{scoreDUnCoup(plateau, coupCourant, couleur, couleur, profondeurMinMax)}
				\sialors{scoreCourant $>$ meilleurScore}{
					\affecter{meilleurCoup}{coupCourant}
					\affecter{meilleurScore}{scoreCourant}
				} %FinSi
			} %FinPour
		} %FinSi
		\retourner{meilleurCoup}

	}
\end{algorithme}



\section{La fonction \tt{scoreDUnCoup}}
\begin{algorithme}
	\fonction
	{scoreDUnCoup}
	{plateau : Plateau, coup : Coup, couleurRef, couleurCourante : Couleur, profondeurCourante : \naturel}
	{\entier}
	{plateauTest : Plateau \\}
	{
	\affecter{plateauTest}{copierPlateau(plateau)}
	\instruction{jouerCoup(coup, plateauTest)}
	\sialorssinon{plateauRempli(plateauTest) ou profondeurCourante $=$ 0}
		{
			\retourner{score(plateauTest, couleurRef)}
		} % Sinon
		{
			\retourner{minMax(plateauTest, couleurRef, changerCouleur(couleurCourante), profondeurCourante $-$ 1)}
		} % FinSi
	} % Fin
\end{algorithme}

\section{La fonction \tt{coupValide}}

\begin{algorithme}

	\fonction{coupValide}
	{plateau : Plateau, coup : Coup}
	{\booleen}
	{pos,posTmp : Position \\
	pionJoueur : Pion \\
	pionPresent : \booleen \\
	x,y : \entier}
	{
	      \affecter{x}{-1}
	      \affecter{pionPresent}{FAUX}
	      \affecter{pos}{obtenirPositionCoup(coup)}
	      \affecter{pionJoueur}{obtenirPionCoup(coup)}
	      \tantque{non(pionPresent) et (x<2)}{
		    \affecter{y}{-1}
		    \tantque{non(pionPresent) et (y<2)}{
			  \sialors{non((x $=$ 0) et (y $=$ 0))}{
				\affecter{posTmp}{pos}
				\instruction{pionEstPresent(pionJoueur, x, y, posTmp, plateau, pionPresent)}
				\sialors{pionPresent}{
				      \sialors{(|obtenirLigne(posTmp) - obtenirLigne(pos)|<2) ou (|obtenirColonne(posTmp) - obtenirColonne(pos)|<2)}{
					    \affecter{pionPresent}{FAUX}
				      }%FinSi
				}%FinSi
			  }%FinSi
			  \affecter{y}{y+1}
		    }%FinTantQue
		    \affecter{x}{x+1}
	      }%FinTantQue
	\retourner{pionPresent}  
	}
\end{algorithme}


\section{La fonction \tt{minMax}}
\begin{algorithme}
	\fonction{minMax}
	{plateau : Plateau, couleurRef, couleurCourante : Couleur, profondeurCourante : \naturel}
	{\entier}
	{coupsPossibles : Coups \\
	resultat, score : \entier \\
	i : \naturel}
	{
	\affecter{coupsPossibles}{listeCoupsPossibles(plateau, couleurCourante)}
	\sialorssinon{nbCoups(coupsPossibles) $>$ 0}
		{
		\affecter{resultat}{scoreDUnCoup(plateau, iemeCoup(coupsPossibles, 1), couleurRef, couleurCourante, profondeurCourante)}
		\pour{i}{2}{nbCoups(coupsPossibles)}{}
			{
			\affecter{score}{scoreDUnCoup(plateau, iemeCoup(coupsPossibles, i), couleurRef, couleurCourante, profondeurCourante)}
			\sialorssinon{couleurCourante $=$ couleurRef}
				{\affecter{resultat}{max(resultat, score)}}
				{\affecter{resultat}{min(resultat, score)}}
			}
		}
		{
		\sialorssinon{couleurCourante $=$ couleurRef}
			{\affecter{resultat}{INFINI}}
			{\affecter{resultat}{$-$ INFINI}}
		}
	\retourner{resultat}
	}
	
	\remarque{On utilise ici une constante \tt{INFINI}, qui représentera un score supérieur à tout autre score, c'est-à-dire un coup gagnant.}
\end{algorithme}
